// prisma/schema.prisma - COMPLETE FILE WITH RETURN COST TRACKING

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Channel {
  id        String   @id @default(cuid())
  code      String   @unique
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  orders    Order[]
  products  Product[]
  inventory Inventory[]
  returns   Return[]
}

model Product {
  id            String    @id @default(cuid())
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  channelRef    String?
  channelId     String
  channel       Channel   @relation(fields: [channelId], references: [id])
  currency      String?
  sku           String
  title         String
  active        Boolean   @default(true)
  priceCents    Int?
  costCents     Int?
  comparePriceCents Int?
  inventory     Inventory?
  orderItems    OrderItem[]
  returnItems   ReturnItem[]
  returnMetrics ProductReturnMetrics[]
  batchAnalysis BatchReturnAnalysis[]
  
  // Additional fields
  weight        Float?
  dimensions    String?
  category      String?
  brand         String?
  supplier      String?
  batchNumber   String?
  shippingClass String?
  shippingMethod String?
  
  @@unique([channelId, sku])
  @@index([sku])
  @@index([channelId])
}

model Order {
  id               String    @id @default(cuid())
  number           String?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  channelRef       String
  channelId        String
  channel          Channel   @relation(fields: [channelId], references: [id])
  currency         String
  subtotalCents    Int
  taxCents         Int
  shippingCents    Int
  shippingCostCents Int?     @default(0)  // What we actually paid to ship (NEW)
  totalCents       Int
  customerEmail    String?
  items            OrderItem[]
  returns          Return[]
  
  // Additional fields for better tracking
  shippingZone     String?
  shippingCarrier  String?
  shippingWeight   Float?
  
  @@unique([channelId, channelRef])
  @@index([channelRef])
  @@index([createdAt])
}

model OrderItem {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  orderId       String
  order         Order    @relation(fields: [orderId], references: [id])
  productId     String?
  product       Product? @relation(fields: [productId], references: [id])
  sku           String
  title         String
  quantity      Int
  priceCents    Int
  totalCents    Int
  returnItems   ReturnItem[]
  
  @@index([orderId])
  @@index([productId])
}

model Inventory {
  id                  String    @id @default(cuid())
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  productId           String    @unique
  product             Product   @relation(fields: [productId], references: [id])
  channelId           String
  channel             Channel   @relation(fields: [channelId], references: [id])
  quantity            Int       @default(0)
  reserved            Int       @default(0)
  available           Int       @default(0)
  reorderPoint        Int       @default(10)
  reorderQuantity     Int       @default(50)
  lastRestockDate     DateTime?
  nextRestockDate     DateTime?
  averageDailySales   Float?
  leadTimeDays        Int       @default(7)
  safetyStockDays     Int       @default(3)
  
  @@index([productId])
  @@index([channelId])
}
model Return {
id                        String      @id @default(cuid())
  returnNumber              String      @unique
  createdAt                 DateTime    @default(now())
  updatedAt                 DateTime    @updatedAt
  orderId                   String
  order                     Order       @relation(fields: [orderId], references: [id])
  channelId                 String
  channel                   Channel     @relation(fields: [channelId], references: [id])
  customerEmail             String
  status                    String      @default("pending")
  totalReturnValueCents     Int
  refundAmountCents         Int?
  restockingFeeCents        Int?        @default(0)
  notes                     String?     @db.Text
  createdBy                 String
  approvedAt                DateTime?
  approvedBy                String?
  completedAt               DateTime?
  items                     ReturnItem[]
  
  // New fields for cost tracking
  shippingCostCents         Int?        @default(0)    // Manual shipping cost entry
  returnLabelCostCents      Int?        @default(0)    // Manual return label cost
  
  @@index([orderId])
  @@index([channelId])
  @@index([status])
  @@index([createdAt])
}


model ReturnItem {
  id                String      @id @default(cuid())
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  returnId          String
  return            Return      @relation(fields: [returnId], references: [id])
  orderItemId       String?
  orderItem         OrderItem?  @relation(fields: [orderItemId], references: [id])
  productId         String?
  product           Product?    @relation(fields: [productId], references: [id])
  sku               String
  productTitle      String
  quantityReturned  Int
  unitPriceCents    Int
  totalValueCents   Int
  
  // Product condition fields
  productCondition  String      @default("100")  // "100", "80", "50", "20"
  conditionNotes    String?     @db.Text
  reasonCategory    String      @default("not_specified")
  reasonDetail      String?     @db.Text
  
  @@index([returnId])
  @@index([productId])
}
// NEW MODELS FOR COST TRACKING

model ProductReturnMetrics {
  id                        String   @id @default(cuid())
  productId                 String
  product                   Product  @relation(fields: [productId], references: [id])
  periodStart               DateTime
  periodEnd                 DateTime
  
  // Sales & Return Volumes
  unitsSold                 Int      @default(0)
  unitsReturned             Int      @default(0)
  returnRate                Float    @default(0)  // 0.0000 to 1.0000
  
  // Cost Analysis
  totalReturnCostsCents     Int      @default(0)
  avgReturnCostCents        Int      @default(0)
  costPerUnitSoldCents      Int      @default(0)  // Spread return costs across all units
  
  // Pricing Impact
  currentPriceCents         Int?
  recommendedPriceCents     Int?     // Price with return costs built in
  marginImpactCents         Int?     // How much returns eat into margin
  
  // Return Reason Breakdown
  defectReturns             Int      @default(0)
  customerRemorseReturns    Int      @default(0)
  notAsDescribedReturns     Int      @default(0)
  damagedInShippingReturns  Int      @default(0)
  otherReturns              Int      @default(0)
  
  createdAt                 DateTime @default(now())
  updatedAt                 DateTime @updatedAt
  
  @@unique([productId, periodStart, periodEnd])
  @@index([productId])
}

model BatchReturnAnalysis {
  id                    String    @id @default(cuid())
  batchNumber           String
  supplierId            String?
  productId             String
  product               Product   @relation(fields: [productId], references: [id])
  
  // Quality Metrics
  totalUnits            Int       @default(0)
  defectiveUnits        Int       @default(0)
  defectRate            Float     @default(0)
  expectedDefectRate    Float     @default(0.02)  // 2% baseline
  excessDefects         Int       @default(0)
  
  // Financial Impact
  extraReturnCostsCents Int       @default(0)
  chargebackAmountCents Int       @default(0)
  chargebackStatus      String?   // 'pending', 'approved', 'disputed', 'collected'
  chargebackDate        DateTime?
  
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  
  @@index([batchNumber])
  @@index([productId])
}

model ReturnCostConfig {
  id            String   @id @default(cuid())
  configType    String   // 'shipping', 'processing', 'restocking'
  configKey     String   // e.g., 'zone_1_cost', 'electronics_fee_percent'
  configValue   Float
  effectiveDate DateTime @default(now())
  notes         String?  @db.Text
  
  @@unique([configType, configKey])
}

// Scheduler Models (keeping existing)
model ScheduledJob {
  id            String   @id @default(cuid())
  name          String   @unique
  type          String   // 'shopify_sync', 'inventory_check', 'report_generation'
  schedule      String   // Cron expression
  enabled       Boolean  @default(true)
  lastRun       DateTime?
  nextRun       DateTime?
  status        String   @default("idle") // 'idle', 'running', 'failed'
  lastError     String?  @db.Text
  config        Json?    // Job-specific configuration
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  executions    JobExecution[]
  
  @@index([enabled, nextRun])
  @@index([type])
}

model JobExecution {
  id            String       @id @default(cuid())
  jobId         String
  job           ScheduledJob @relation(fields: [jobId], references: [id])
  startedAt     DateTime     @default(now())
  completedAt   DateTime?
  status        String       // 'running', 'completed', 'failed'
  recordsProcessed Int?
  error         String?      @db.Text
  logs          Json?        // Detailed execution logs
  
  @@index([jobId])
  @@index([status])
  @@index([startedAt])
}
